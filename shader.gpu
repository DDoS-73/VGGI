// Vertex shader
const vertexShaderSource = `
attribute vec3 vertex;
attribute vec2 textureCoord;

uniform vec2 pTexture;
uniform vec3 pTranslate;
uniform float fScale;

varying vec2 texInterp;

uniform mat4 ModelViewProjectionMatrix, ModelViewInverseTranspose;

mat4 translatePoint(vec3 point) {
  return mat4(
    vec4(1.0, 0.0, 0.0, point.x),
    vec4(0.0, 1.0, 0.0, point.y),
    vec4(0.0, 0.0, 1.0, point.z),
    vec4(0.0, 0.0, 0.0, 1.0)
  );
}

mat4 scale(float fScale) {
    return mat4(
        vec4(fScale, 0.0, 0.0, 0.0),
        vec4(0.0, fScale, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );
}

void main() {
    if(fScale < 0.0){
        vec4 point = vec4(vertex, 1.0) * translatePoint(pTranslate);
        gl_Position = ModelViewProjectionMatrix * point;
    } else {
        vec4 vertPos4 = ModelViewProjectionMatrix * vec4(vertex, 1.0);
        gl_Position = vertPos4;
    }

    mat4 matTranslateToZero = translatePoint(-vec3(pTexture, 0.0));
    mat4 matScale = scale(fScale);
    mat4 matTranslateBackToPoint = translatePoint(vec3(pTexture, 0.0));

    vec4 translatedToZero =  matTranslateToZero * vec4(texCoord, 0.0, 0.0);
    vec4 scaled = translatedToZero * matScale;
    vec4 translatedBackToPoint = scaled * matTranslateBackToPoint;

    texInterp = vec2(translatedBackToPoint.x, translatedBackToPoint.y);

    gl_PointSize = 20.0;
}`;

// Fragment shader
const fragmentShaderSource = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
   precision highp float;
#else
   precision mediump float;
#endif

varying vec2 texInterp;
uniform sampler2D tmu;
uniform float fScale;

void main() {
    if(fScale < 0.0){
        gl_FragColor = vec4(1.0, 0.0 , 0.0 , 0.0);
    } else {
        gl_FragColor = texture2D(tmu, texInterp);
    }
}`;
